$ the command I typed in linux
// the output/explanation/comments


1. Set up the environments
$ scp ./coreutils-with-bug.tar.gz classrui@lnxsrv07.seas.ucla.edu:/u/eng/class/classrui/35L/hm4
//upload coreutils-with-bug to linux server
$ cd 35L/hm4
$ tar -xzvf coreutils-with-bug.tar.gz
//Uncompress the file
$ cd coreutils-with-bug
$ ./configure --prefix=/u/eng/class/classrui/bad_coreutils
//generate a Makefile for this package, and create a path for make install to install it in a temporary directory
//Last line of output: config.status: creating po/Makefile
$ make
//To compile this package, however, there is an error message says that:
utimens.h:2:5: error: conflicting types for 'futimens'
 int futimens (int, char const *, struct timespec const [2]);
     ^
In file included from utimecmp.h:25:0,
                 from utimecmp.c:25:
/usr/include/sys/stat.h:373:12: note: previous declaration of 'futimens' was here
 extern int futimens (int __fd, const struct timespec __times[2]) __THROW;
            ^
$ make install
//To install this bugged version into the temporary directory, and the same error message is also generated by this command


2. Fix the bug with patch
$ wget https://web.cs.ucla.edu/classes/fall19/cs35L/assign/coreutils.diff
//download the patch content for rename into coreutils.diff
$ patch -p0 < coreutils.diff
//Apply the patch file
//use -p0 because the path listed in the patch file is like "lib/utimens.c", and I am currently at the directory that contains lib. So using -p0 to look for lib under my current directory can sucessfully locate utimens.c
$ ./configure --prefix=/u/eng/class/classrui/bad_coreutils
$ make
$ make install
//re-compile the patched version of coreutils, and install a temporary version of it in another directory
//The reason of compilation error in make is that there are two functions that have the same name and has been declared twice. And this patch fixed the repetitive names with a prefix "coreutils_", so this code could compile successfully.


3. Reproduce the bug in a temp directory
$ tmp=$(mktemp -d)
$ cd $tmp
$ touch -d '1918-11-11 11:00 GMT' wwi-armistice-cs35L
$ touch now
$ sleep 1
$ touch now1
$ TZ=UTC0 ~/35L/hm4/coreutils-with-bug/src/ls -lt --full-time wwi-armistice-cs35L now now1
-rw-r--r-- 1 classrui class 0 1918-11-11 11:00:00.000000000 +0000 wwi-armistice-cs35L
-rw-r--r-- 1 classrui class 0 2019-10-25 02:13:11.768735787 +0000 now1
-rw-r--r-- 1 classrui class 0 2019-10-25 02:12:38.853725076 +0000 now
//Reproduce the bug with my downloaded version of ls
//Problem with output: The output is supposed to be arranged in chronological order, with the newer file in the front. However, the oldest file, generated with date back to 1918, appears in the front. So we want to fix that.


4. Debugging with gdb
$ cd 35L/hm4/coreutils-with-bug/src
$ gdb ls
(gdb) info functions
//To see which function(s) is related to time in ls, and there are 6 potential functions:
static int compare_atime(V, V);
static int compare_ctime(V, V);
static int compare_mtime(V, V);
static int compstr_atime(V, V);
static int compstr_ctime(V, V);
static int compstr_mtime(V, V);
(gdb) b compare_atime
//I first set breakpoint to function compare_atime to see whether it is problematic
(gdb) run -lt
//ls.c runs successfully without stopping at any time, so compare_atime is not the cause for this bug
(gdb) delete 1
(gdb) b compare_ctime
//Then set breakpoint to function compare_ctime to see whether it is problematic
(gdb) run -lt
//The bug is still there and the program does not stop at this breakpoints, so this function is not the cause neither
(gdb) delete 2
(gdb) b compare_mtime
//Set breakpoint to the third function
(gdb) run -lt
//The program stops at this breakpoint, so use s to examine how this function works
(gdb) s
//cmp_mtime (cmp=0x404350 <xstrcoll>, b=0x62b050, a=0x62afa0) at ls.c:2884
2884	static int compare_mtime (V a, V b) { return cmp_mtime (a, b, xstrcoll); }
(gdb) si
//timespec_cmp (b=..., a=...) at ../lib/timespec.h:49
49	  return diff ? diff : a.tv_nsec - b.tv_nsec;
//This function seems like the root cause for this bug, because it returns the comparison result for two objects(maybe they store the time for each file), so I quit the gdb and go to timespec.h to examine it
(gdb) q


5. Fix the bug with a new timespec.h	
$ cd ../lib
$ less timespec.h
//The details of this function is:
  /* Return negative, zero, positive if A < B, A == B, A > B, 	respectively.
     Assume the nanosecond components are in range, or close to it.  */
  static inline int
  timespec_cmp (struct timespec a, struct timespec b)
  {
    int diff = a.tv_sec - b.tv_sec;
    return diff ? diff : a.tv_nsec - b.tv_nsec;
  }
//The problem with this comparison is that if the difference between a and b is very huge, (exceed the INT_MAX or INT_MIN in this machine), then there will be an overflow. Assume timespec a is the file created in 1918, and timespec b is the file created today. Then a.tv_nsec - b.tv_nsec, which is supposed to be a negative integer, overflows and becomes positive. That's way the file created in 1918 ranks first.
$ cp timespec.h new_timespec.h
$ emacs new_timespec.h
static inline int
timespec_cmp (struct timespec a, struct timespec b)
{
  if (a.tv_sec > b.tv_sec)
    return 1;
  else if (a.tv_sec < b.tv_sec)
    return -1;
  return 0;
}
//Instead of using subtractions, I directly compares two numbers and return 1, -1, 0 if A>B, A<B, A==B, respectively.

6. Create a ChangeLog
$ diff -u timespec.h new_timespec.h
//output:
+++ new_timespec.h	2019-10-24 20:49:50.794767000 -0700
@@ -45,8 +45,11 @@
 static inline int
 timespec_cmp (struct timespec a, struct timespec b)
 {
-  int diff = a.tv_sec - b.tv_sec;
-  return diff ? diff : a.tv_nsec - b.tv_nsec;
+  if (a.tv_sec > b.tv_sec)
+    return 1;
+  else if (a.tv_sec < b.tv_sec)
+    return -1;
+  return 0;
 }
 
 # if ! HAVE_DECL_NANOSLEEP
$ emacs timespec.h
(emacs) C-x 4 a
//This command helps create a ChangeLog entry in this file, and I write:
  2019-10-24  Rui Deng  <classrui@lnxsrv07.seas.ucla.edu>

        * timespec.h (timespec_comp): Changed comparison mechanism from 	subtraction to	direct	comparison to avoid overflow. This function 	now returns 1, -1, 0if A>B, A<B, A==B, respectively.
$ emacs lab4.diff
//Create a patch file with content of the ChangeLog and output of diff -u
$ patch -p0 < lab4.diff
//output: Hunk #1 succeeded at 45 with fuzz 1.
$ make
//build the program again to activitate the patch


7. Test the patch
$ tmp=$(mktemp -d)
$ cd $tmp
$ touch -d '1918-11-11 11:00 GMT' wwi-armistice-cs35L
$ touch now
$ sleep 1
$ touch now1
$ TZ=UTC0 ~/35L/hm4/coreutils-with-bug/src/ls -lt --full-time wwi-armistice-cs35L now now1
-rw-r--r-- 1 classrui class 0 2019-10-25 04:42:52.457419226 +0000 now1
-rw-r--r-- 1 classrui class 0 2019-10-25 04:42:43.754151970 +0000 now
-rw-r--r-- 1 classrui class 0 1918-11-11 11:00:00.000000000 +0000 wwi-armistice-cs35L
//The output is correct now

8. Run ls in linux server
$ cd ~
//Go back to the home directory and create wwi-armistice-cs35L, now, now1 following the step above
$ ls -lt --full-time wwi-armistice-cs35L now now1
-rw-r--r-- 1 classrui class 0 2054-12-17 09:28:16.000000000 -0800 wwi-armistice-cs35L
-rw-r--r-- 1 classrui class 0 2019-10-24 19:04:06.884433000 -0700 now1
-rw-r--r-- 1 classrui class 0 2019-10-24 19:03:59.055392000 -0700 now
//I searched this result online and find that most linux server uses EPOCH time, which starts at Jan 1, 1970 00:00:00. And the file system cannot deal with negative time generated before 1970; thus they assign the positive counterpart of time, which is far in the future.
